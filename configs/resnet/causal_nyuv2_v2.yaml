data:
  type: "nyuv2"
  # 确保路径正确
  dataset_path: "/data/chengfengwu/alrl/mtl_dataset/nyuv2"
  # 诊断时 Batch Size 可以小一点，或者保持 8
  batch_size: 2
  num_workers: 4
  img_size: [288, 384] # 保持和 SOTA 一致的分辨率
  pin_memory: true

model:
  type: "causal"         # 借用 Causal 架构来测 ResNet50
  encoder_name: "resnet50"
  pretrained: true
  latent_dim_s: 128
  latent_dim_p: 256
  # NYUv2 参数占位
  num_seg_classes: 40
  num_scene_classes: 27

  decomposition:
    enabled: true
    light_head:
      sh_degree: 2

training:
  seed: 2025
  epochs: 100            # 跑久一点看极限
  optimizer: "AdamW"
  learning_rate: 0.0005  # 稍微调大 LR 激进一点
  weight_decay: 0.0      # 【关键】关掉正则，我们要看模型能不能“记住”数据

  # 【关键】跳过所有预热，直接全参数训练
  stage0_epochs: 0
  stage1_epochs: 0
  ind_warmup_epochs: 0

  lr_scheduler:
    type: "step"
    step_size: 50
    gamma: 0.5

losses:
  # === 关闭所有其他任务 ===
  lambda_seg: 0.0
  lambda_normal: 0.0
  lambda_scene: 0.0

  # === 深度权重 ===
  # NYUv2 用的是 ScaleInvariantLoss，数值通常在 0.1~0.5 之间
  # 不需要设像 Cityscapes (L1) 那么大，设 10.0 足够观测了
  lambda_depth: 10.0

  # 关闭解耦和重构，只测 "Input -> Depth" 的拟合能力
  lambda_independence: 0.0
  alpha_recon_geom: 0.0
  beta_recon_app: 0.0
  lambda_l1_recon: 0.0

  # 关闭正则
  lambda_edge_consistency: 0.0
  lambda_img: 0.0
  lambda_sh_gray: 0.0