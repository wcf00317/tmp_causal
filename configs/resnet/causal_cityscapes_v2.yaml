# configs/diagnose_depth_limit_resnet.yaml
# 修复版：使用 "causal" 模式但只训练深度，用于探测 ResNet50 架构的深度拟合极限

data:
  type: "cityscapes"
  dataset_path: "/data/chengfengwu/alrl/mtl_dataset/cityscape_preprocess"
  # 诊断时不需要太大 Batch，目的是看能不能过拟合
  batch_size: 4
  num_workers: 4
  # 保持和你主实验一致的分辨率，看看这个分辨率下 Abs Err 能降到多少
  img_size: [128, 256]
  pin_memory: true

model:
  # [CRITICAL Fix] 必须用 "causal"，因为 SingleTaskModel 代码不支持 resnet50
  type: "causal"
  encoder_name: "resnet50"
  pretrained: true
  latent_dim_s: 128
  latent_dim_p: 256
  # 即使只测深度，这些参数也需要占位以防报错
  num_seg_classes: 7
  num_scene_classes: 1

  decomposition:
    enabled: true
    light_head:
      sh_degree: 2

training:
  seed: 2025
  epochs: 100
  optimizer: "AdamW"
  learning_rate: 0.001   # [高 LR] 1e-3，为了快速过拟合测试
  weight_decay: 0.0      # [无正则] 关掉正则化，方便逼近极限

  # [关键策略] 直接进入 Stage 2 (全解冻模式)，跳过预热
  # 这样所有参数（Encoder + Decoder）从第一步开始都全力服务于深度
  stage0_epochs: 0
  stage1_epochs: 0
  ind_warmup_epochs: 0

  lr_scheduler:
    type: "step"
    step_size: 50
    gamma: 0.5

losses:
  # === 所有的权重都设为 0，只保留 Depth ===
  lambda_seg: 0.0

  # [重点] 这里的 1.0 是 L1 Loss 的直接权重
  # 如果 1.0 下降慢，可以改成 10.0 或 50.0，但在单任务下 1.0 通常足够观察趋势
  lambda_depth: 1.0

  lambda_normal: 0.0
  lambda_scene: 0.0

  # 关闭解耦约束
  lambda_independence: 0.0

  # 关闭重构（为了纯粹测试 "Input -> Depth" 的拟合能力）
  # 如果你想测试 "zs -> Depth" 的能力，也可以保留 alpha_recon_geom
  alpha_recon_geom: 0.0
  beta_recon_app: 0.0
  lambda_l1_recon: 0.0

  # 关闭边缘一致性等正则项，只看最原始的拟合能力
  lambda_edge_consistency: 0.0

  # 关闭分解
  lambda_img: 0.0
  lambda_sh_gray: 0.0